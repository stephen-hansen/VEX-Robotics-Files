#pragma config(Sensor, in1,    controlSwitch,  sensorAnalog)
#pragma config(Motor,  port4,           FL,            tmotorVex393, openLoop)
#pragma config(Motor,  port5,           FR,            tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           BL,            tmotorVex393, openLoop)
#pragma config(Motor,  port7,           BR,            tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(145)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

int modifySpeed = 1; // useful in case our robot is "too fast"
//bool isPressed = false; // to be used in the speed cycler

// TO DO: change wait statements to encoder statements

void drive(int leftSpeed, int rightSpeed, int time) { //primitive function meant for debugging
	motor[FL] = (leftSpeed)/(modifySpeed);
	motor[BL] = (leftSpeed)/(modifySpeed);
	motor[BR] = (rightSpeed)/(modifySpeed);
	motor[FR] = (rightSpeed)/(modifySpeed);
	wait1Msec(time);
}
void debugControls() {
	// simplistic movement
	if ((vexRT[Btn8U]) == 1) { // go forward one square
		drive(127,127,1000);
  }
  if ((vexRT[Btn8D]) == 1) { // go backwards one square
		drive(-127,-127,1000);
  }
  if ((vexRT[Btn8L]) == 1) { // turn 90 degrees left
		drive(-127,127,585);
  }
  if ((vexRT[Btn8R]) == 1) { // turn 90 degrees right
		drive(127,-127,585);
  }
  // speed changing
  if ((vexRT[Btn7U]) == 1) { // set speed to full speed
		modifySpeed = 1;
  }
  if ((vexRT[Btn7L]) == 1) { // set speed to half speed
		modifySpeed = 2;
  }
  if ((vexRT[Btn7D]) == 1) { // set speed to third speed
		modifySpeed = 3;
  }
  if ((vexRT[Btn7R]) == 1) { // set speed to quarter speed
		modifySpeed = 4;
  }
}
/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	while (true)
	{
		if (SensorValue(controlSwitch) > 1) //if theres no switch then tank controls
		{
			while(true)
			{
				motor[BL] = (vexRT[Ch3])/modifySpeed; //left is controlled by left joystick
				motor[FL] = (vexRT[Ch3])/modifySpeed;
				motor[BR] = (vexRT[Ch2])/modifySpeed; //right is controlled by right joystick
				motor[FR] = (vexRT[Ch2])/modifySpeed;
				debugControls();
		  }
	  }
	  else if (SensorValue(controlSwitch) == 0) //if theres a switch then enable experimental motion controls
	  {
	  	while(true)
	  	{
				if (abs(vexRT[AccelX]) > abs(vexRT[AccelY])) //if absolute value of LR > absolute value of UD
				{
					motor[BR] = (-(vexRT[AccelX]))/modifySpeed; //LR is the chosen control
					motor[FR] = (-(vexRT[AccelX]))/modifySpeed; //right side is inverted speed of LR
					motor[BL] = (vexRT[AccelX])/modifySpeed; //left side isnt inverted
					motor[FL] = (vexRT[AccelX])/modifySpeed; //so that it turns in direction of LR
				}
				else if (abs(vexRT[AccelY]) >= abs(vexRT[AccelX])) //if absolute value of LR <= absolute value of UD
				{
					motor[BR] = (-(vexRT[AccelY]))/modifySpeed; //UD is the chosen control
					motor[FR] = (-(vexRT[AccelY]))/modifySpeed; //drive forwards/backwards at UD speed
					motor[BL] = (-(vexRT[AccelY]))/modifySpeed;
					motor[FL] = (-(vexRT[AccelY]))/modifySpeed;
		  	}
		  	debugControls();
			}
	  }
	}
}
