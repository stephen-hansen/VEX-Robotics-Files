#pragma config(Sensor, in1,    controlSwitch,  sensorAnalog)
#pragma config(Motor,  port2,           ALT,           tmotorVex393, openLoop)
#pragma config(Motor,  port3,           ALB,           tmotorVex393, openLoop)
#pragma config(Motor,  port4,           FL,            tmotorVex393, openLoop)
#pragma config(Motor,  port5,           FR,            tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           BL,            tmotorVex393, openLoop)
#pragma config(Motor,  port7,           BR,            tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           ARB,           tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           ART,           tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(145)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//int modifySpeed = 1; // useful in case our robot is "too fast"
//bool isPressed = false; // to be used in the speed cycler

// TO DO: change wait statements to encoder statements

void drive(int leftSpeed, int rightSpeed, int time) { //primitive function meant for debugging
	motor[FL] = (leftSpeed);///(modifySpeed));
	motor[BL] = (leftSpeed);///(modifySpeed));
	motor[BR] = (rightSpeed);///(modifySpeed));
	motor[FR] = (rightSpeed);///(modifySpeed));
	wait1Msec(time);
	motor[FL] = 0;///(modifySpeed));
	motor[BL] = 0;///(modifySpeed));
	motor[BR] = 0;///(modifySpeed));
	motor[FR] = 0;///(modifySpeed));
}
void debugControls() {
	// simplistic movement
	if ((vexRT[Btn8U]) == 1) { // go forward one square
		drive(127,127,1000);
  }
  if ((vexRT[Btn8D]) == 1) { // go backwards one square
		drive(-127,-127,1000);
  }
  if ((vexRT[Btn8L]) == 1) { // turn 90 degrees left
		drive(-127,127,585);
  }
  if ((vexRT[Btn8R]) == 1) { // turn 90 degrees right
		drive(127,-127,585);
  }
  // speed changing
  /*if ((vexRT[Btn7U]) == 1) { // set speed to full speed
		modifySpeed = 1;
  }
  if ((vexRT[Btn7L]) == 1) { // set speed to half speed
		modifySpeed = 2;
  }
  if ((vexRT[Btn7D]) == 1) { // set speed to third speed
		modifySpeed = 3;
  }
  if ((vexRT[Btn7R]) == 1) { // set speed to quarter speed
		modifySpeed = 4;
  }*/
}
/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	drive(127,127,1000);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	while (true)
	{
		if (SensorValue(controlSwitch) > 1) //if theres no switch then tank controls
		{
			while(true)
			{
				motor[BL] = (vexRT[Ch3]);///modifySpeed); //left is controlled by left joystick
				motor[FL] = (vexRT[Ch3]);///modifySpeed);
				motor[BR] = (vexRT[Ch2]);///modifySpeed); //right is controlled by right joystick
				motor[FR] = (vexRT[Ch2]);///modifySpeed);
				debugControls();
	   		motor[ALB]=(vexRT[Ch3Xmtr2]); //partner controls lift with left joystick
	   		motor[ALT]=(vexRT[Ch3Xmtr2]);
		 		motor[ARB]=(vexRT[Ch3Xmtr2]);
		 		motor[ART]=(vexRT[Ch3Xmtr2]);
		  }
	  }
	  else if (SensorValue(controlSwitch) == 0) //if theres a switch then enable experimental motion controls
	  {
	  	while(true)
	  	{
				if (abs(vexRT[AccelX]) > abs(vexRT[AccelY])) //crazy motion controls that mimick a wii remote
				{
					motor[BR] = (-(vexRT[AccelX])) / 2;///modifySpeed); //turning is the chosen control
					motor[FR] = (-(vexRT[AccelX])) / 2;///modifySpeed); //right side is inverted speed of LR
					motor[BL] = (vexRT[AccelX]) / 2;///modifySpeed); //left side isnt inverted
					motor[FL] = (vexRT[AccelX]) / 2;///modifySpeed); //so that it turns in direction of the controller
				}
				else if (abs(vexRT[AccelY]) >= abs(vexRT[AccelX])) //check the direction of the controller's tilt
				{
					motor[BR] = (-(vexRT[AccelY])) / 2;///modifySpeed); //driving is the chosen control
					motor[FR] = (-(vexRT[AccelY])) / 2;///modifySpeed); //drive forwards/backwards at tilted speed
					motor[BL] = (-(vexRT[AccelY])) / 2;///modifySpeed);
					motor[FL] = (-(vexRT[AccelY])) / 2;///modifySpeed);
		  	}
		  	debugControls();
		  	motor[ALB]=(vexRT[AccelZXmtr2]); //partner controls lift
	   		motor[ALT]=(vexRT[AccelZXmtr2]);
		 		motor[ARB]=(vexRT[AccelZXmtr2]);
		 		motor[ART]=(vexRT[AccelZXmtr2]);
			}
	  }
	}
}
