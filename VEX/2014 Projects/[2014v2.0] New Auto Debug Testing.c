#pragma config(Sensor, in1,    controlSwitch,  sensorAnalog)
#pragma config(Motor,  port2,           ALT,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           ALB,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           FL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           FR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           BL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           BR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           ARB,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           ART,           tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(145)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//int modifySpeed = 1; // useful in case our robot is "too fast"
//bool isPressed = false; // to be used in the speed cycler

// TO DO: change wait statements to encoder statements

void drive(int leftSpeed, int rightSpeed, int time) { //primitive function meant for debugging
	motor[FL] = (leftSpeed);///(modifySpeed));
	motor[BL] = (leftSpeed);///(modifySpeed));
	motor[BR] = (rightSpeed);///(modifySpeed));
	motor[FR] = (rightSpeed);///(modifySpeed));
	wait1Msec(time);
	motor[FL] = 0;///(modifySpeed));
	motor[BL] = 0;///(modifySpeed));
	motor[BR] = 0;///(modifySpeed));
	motor[FR] = 0;///(modifySpeed));
}
void lift(int speed, int lifttime) { // tells arm motors to lift for set amount of time
	motor[ALB] = speed;
	motor[ALT] = speed;
	motor[ARB] = speed;
	motor[ART] = speed;
	wait1Msec(lifttime); // do you even lift
	motor[ALB] = 0;
	motor[ALT] = 0;
	motor[ARB] = 0;
	motor[ART] = 0;
}
void debugControls() {
	// simplistic movement
	if ((vexRT[Btn8U]) == 1) { // go forward one square
		drive(127,127,666);
  }
  if ((vexRT[Btn8D]) == 1) { // go backwards one square
		drive(-127,-127,666);
  }
  if ((vexRT[Btn8L]) == 1) { // turn 90 degrees left
		drive(-127,127,351);
  }
  if ((vexRT[Btn8R]) == 1) { // turn 90 degrees right
		drive(127,-127,351);
  }
  // speed changing
  /*if ((vexRT[Btn7U]) == 1) { // set speed to full speed
		modifySpeed = 1;
  }
  if ((vexRT[Btn7L]) == 1) { // set speed to half speed
		modifySpeed = 2;
  }
  if ((vexRT[Btn7D]) == 1) { // set speed to third speed
		modifySpeed = 3;
  }
  if ((vexRT[Btn7R]) == 1) { // set speed to quarter speed
		modifySpeed = 4;
  }*/
}

void simpleAuto() { // Autonomous program to be used when we are not scoring peg pieces in autonomous
	lift(127,1000); // lift up a bit
	drive(127,127,333); // drive forward
	lift(-127,1000); // lift down a bit
	drive(-127,-127,333); // drive backwards
}

void advAutoRed() { // Autonomous peg moving for red team
	lift(127,500); // lift up cube a bit
	drive(127,127,333); // drive forward
	lift(-127,500); // drop cube
	drive(-127,-127,333); // drive back a bit
	drive(127,-127,351); // turn 90 deg right
	lift(127,1000); // lift up more
	drive(127,127,333); // drive forward a bit
	lift(127,500); // lift up a little more
	drive(-127,-127,333); // drive back
	drive(-127,127,351); // turn 90 deg left
	drive(127,127,333); // drive forward a bit
	lift(-127,1250); // lift down some
	drive (-127,-127,333); // drive back
}

void advAutoBlu() { // Autonomous peg moving for blu team
	lift(127,500); // lift up cube a bit
	drive(127,127,333); // drive forward
	lift(-127,500); // drop cube
	drive(-127,-127,333); // drive back a bit
	drive(-127,127,351); // turn 90 deg left
	lift(127,1000); // lift up more
	drive(127,127,333); // drive forward a bit
	lift(127,500); // lift up a little more
	drive(-127,-127,333); // drive back
	drive(127,-127,351); // turn 90 deg right
	drive(127,127,333); // drive forward a bit
	lift(-127,1250); // lift down some
	drive(-127,-127,333); // drive back
}

void liftControls() // for partner 2
{
	if (vexRT[Btn8UXmtr2] == 1) //if P2 8U is pressed
  {
		motor[ALT] = 127; //lift up
		motor[ALB] = 127;
		motor[ART] = 127;
		motor[ARB] = 127;
	}
	else if (vexRT[Btn8DXmtr2] == 1) //else if P2 8D is pressed
	{
		motor[ALT] = -127; //lift down
		motor[ALB] = -127;
		motor[ART] = -127;
		motor[ARB] = -127;
  }
  else
	{
		motor[ALT] = 0; //do nothing
		motor[ALB] = 0;
		motor[ART] = 0;
		motor[ARB] = 0;
	}
}
/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	simpleAuto();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	while (true)
	{
		if (SensorValue(controlSwitch) > 1) //if theres no switch then tank controls
		{
			while(true)
			{
				motor[BL] = (vexRT[Ch3]);///modifySpeed); //left is controlled by left joystick
				motor[FL] = (vexRT[Ch3]);///modifySpeed);
				motor[BR] = (vexRT[Ch2]);///modifySpeed); //right is controlled by right joystick
				motor[FR] = (vexRT[Ch2]);///modifySpeed);
				debugControls(); // debug controls for player 1 (uses buttons)
	   		liftControls(); // lift controls for player 2 (uses buttons)
		  }
	  }
	  else if (SensorValue(controlSwitch) == 0) //if theres a switch then enable experimental motion controls
	  {
	  	while(true)
	  	{
				if (abs(vexRT[AccelX]) > abs(vexRT[AccelY])) //crazy motion controls that mimick a wii remote
				{
					motor[BR] = (-(vexRT[AccelX])) / 2;///modifySpeed); //turning is the chosen control
					motor[FR] = (-(vexRT[AccelX])) / 2;///modifySpeed); //right side is inverted speed of LR
					motor[BL] = (vexRT[AccelX]) / 2;///modifySpeed); //left side isnt inverted
					motor[FL] = (vexRT[AccelX]) / 2;///modifySpeed); //so that it turns in direction of the controller
				}
				else if (abs(vexRT[AccelY]) >= abs(vexRT[AccelX])) //check the direction of the controller's tilt
				{
					motor[BR] = (-(vexRT[AccelY])) / 2;///modifySpeed); //driving is the chosen control
					motor[FR] = (-(vexRT[AccelY])) / 2;///modifySpeed); //drive forwards/backwards at tilted speed
					motor[BL] = (-(vexRT[AccelY])) / 2;///modifySpeed);
					motor[FL] = (-(vexRT[AccelY])) / 2;///modifySpeed);
		  	}
		  	debugControls();
		  	motor[ALB]=(vexRT[AccelZXmtr2]); //partner controls lift
	   		motor[ALT]=(vexRT[AccelZXmtr2]);
		 		motor[ARB]=(vexRT[AccelZXmtr2]);
		 		motor[ART]=(vexRT[AccelZXmtr2]);
			}
	  }
	}
}
