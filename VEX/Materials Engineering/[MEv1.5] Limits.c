#pragma config(Sensor, in3,    line,           sensorLineFollower)
#pragma config(Sensor, dgtl3,  sonar,          sensorSONAR_cm)
#pragma config(Motor,  port2,           FL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           BL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           FR,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           BR,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          flashlight,    tmotorVexFlashlight, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
float pitch = 0.25;
int count = 1;
int CHANGE = 50; //CHANGE SPEED
int bpm = 120; //BEATS PER MINUTE
int spm = 600; //STROBE PER MINUTE
string power = "off";
string recordS = "ready";
float rec[100];
int recBpm[100];

//timing = 60000/bpm
//TODO:
//Be able to turn off light
//Convert light to fader because of epilepsy
//Get wheels/motors
//Add recorder [Done-ish, need to add alert]

task music () {
	count = 1;
	int ignore = SensorValue[sonar];
	while (true) {
		if(bSoundQueueAvailable && SensorValue[sonar] < ignore) // if there is still space in the Sound Queue:
		{
			playImmediateTone(abs(SensorValue[sonar])*pitch, 50);  // play tone according to sensor readings
			wait1Msec((60000/bpm));
			if (recordS == "startReady") {
				rec[(count)] = abs(SensorValue[sonar])*pitch;
				recBpm[(count)] = bpm;
				count = count + 1;
			}
		}
	}
}

task debug () {
	clearLCDLine(0);
	clearLCDLine(1);
	while (true) {
		bLCDBacklight = true;									// Turn on LCD Backlight
		displayLCDPos(0,0);
		string display1;
		sprintf(display1, "BPM: %3d STR: %3d", bpm, spm);
		displayNextLCDString(display1);
		displayLCDPos(1,0);
		string display2;
		sprintf(display2, "PITCH: %4f", pitch);
		displayNextLCDString(display2);
	}
}

task bpmConfig () {
	clearLCDLine(0);
	clearLCDLine(1);
	while (true) {
		bLCDBacklight = true;									// Turn on LCD Backlight
		displayLCDPos(0,0);
		string display1;
		sprintf(display1, " CONFIGURE  BPM ");
		displayNextLCDString(display1);
		displayLCDPos(1,0);
		string display2;
		sprintf(display2, "    BPM: %3d    ", bpm);
		displayNextLCDString(display2);
	}
}

task spmConfig () {
	clearLCDLine(0);
	clearLCDLine(1);
	while (true) {
		bLCDBacklight = true;									// Turn on LCD Backlight
		displayLCDPos(0,0);
		string display1;
		sprintf(display1, "CONFIGURE STROBE");
		displayNextLCDString(display1);
		displayLCDPos(1,0);
		string display2;
		sprintf(display2, "STROBE RATE: %3d", spm);
		displayNextLCDString(display2);
	}
}

task pitchConfig () {
	clearLCDLine(0);
	clearLCDLine(1);
	while (true) {
		bLCDBacklight = true;									// Turn on LCD Backlight
		displayLCDPos(0,0);
		string display1;
		sprintf(display1, "CONFIGURE  PITCH");
		displayNextLCDString(display1);
		displayLCDPos(1,0);
		string display2;
		sprintf(display2, "  PITCH:  %4f  ", pitch);
		displayNextLCDString(display2);
	}
}

task strobe() {
	while (true) {
		motor[flashlight] = 127;
		wait1Msec(60000/spm);
		motor[flashlight] = 0;
		wait1Msec(60000/spm);
	}
}

void tank() {
	motor[FL] = vexRT[Ch3];
	motor[BL] = vexRT[Ch3];
	motor[FR] = vexRT[Ch2];
	motor[BR] = vexRT[Ch2];
}

void tankMotion() {
	if (abs(vexRT[AccelX]) > abs(vexRT[AccelY])) {
		motor[BR] = (-(vexRT[AccelX])) / 2;
		motor[FR] = (-(vexRT[AccelX])) / 2;
		motor[BL] = (vexRT[AccelX]) / 2;
		motor[FL] = (vexRT[AccelX]) / 2;
		} else if (abs(vexRT[AccelY]) >= abs(vexRT[AccelX])) {
		motor[BR] = (-(vexRT[AccelY]));
		motor[FR] = (-(vexRT[AccelY]));
		motor[BL] = (-(vexRT[AccelY]));
		motor[FL] = (-(vexRT[AccelY]));
	}
}

int X2 = 0, Y1 = 0, X1 = 0, threshold = 15;
void tankMecanum() {
	//Create "deadzone" for Y1/Ch3
	if (abs(vexRT[Ch3]) > threshold) {
		Y1 = vexRT[Ch3];
		} else {
		Y1 = 0;
	}
	//Create "deadzone" for X1/Ch4
	if (abs(vexRT[Ch4]) > threshold) {
		X1 = vexRT[Ch4];
		} else {
		X1 = 0;
	}
	//Create "deadzone" for X2/Ch1
	if (abs(vexRT[Ch1]) > threshold) {
		X2 = vexRT[Ch1];
		} else {
		X2 = 0;
	}
	//Remote Control Commands
	motor[FR] = Y1 - X2 - X1;
	motor[BR] =  Y1 - X2 + X1;
	motor[FL] = Y1 + X2 + X1;
	motor[BL] =  Y1 + X2 - X1;
}

void tankMotionMecanum() {
	if (abs(vexRT[AccelY]) > threshold) {
		Y1 = -(vexRT[AccelY]);
		} else {
		Y1 = 0;
	}
	//Create "deadzone" for X1/Ch4
	if ((abs(vexRT[AccelX]) > threshold) && (vexRT[Btn5D] == 0)) {
		X1 = (vexRT[AccelX]);
		} else {
		X1 = 0;
	}
	//Create "deadzone" for X2/Ch1
	if ((abs(vexRT[AccelX]) > threshold) && (vexRT[Btn5D] == 1)) {
		X2 = (vexRT[AccelX])/2;
		} else {
		X2 = 0;
	}
	//Remote Control Commands
	motor[FR] = Y1 - X2 - X1;
	motor[BR] =  Y1 - X2 + X1;
	motor[FL] = Y1 + X2 + X1;
	motor[BL] =  Y1 + X2 - X1;
}

task playback() {
	count = 1;
	while (true) {
		if (rec[(count)] != 0) {
			playImmediateTone(rec[(count)], 50);  // play tone according to sensor readings
			wait1Msec((60000/recBpm[(count)]));
			count = count + 1;
		}	else {
			count = 1;
		}
	}
}

void record()
{
	if (vexRT[Btn8U] == 1) {
		if (recordS == "ready") {
			recordS = "start";
			stopTask(playback);
			for (int i = 0; i < ARRAYSIZE(rec); i++) {
				rec[i] = 0;
				recBpm[i] = 0;
			}
		}	else if (recordS == "startReady") {
			recordS = "finish";
			stopTask(music);
		}
	}	else {
		if (recordS == "start") {
			recordS = "startReady";
			startTask(music);
		}	else if (recordS == "finish") {
			recordS = "ready";
			startTask(playback);
		}
	}
}

string mode = "debug";
task main()
{
	while (true) {
		if (power == "on") {
			record();
			tank();
			if (mode == "debug") {
				stopTask(bpmConfig);
				stopTask(spmConfig);
				stopTask(pitchConfig);
				startTask(debug);
				mode = "";
				wait1Msec(1000);
			}
			else if (nLCDButtons == 1 || mode == "bpm") {
				mode = "bpm";
				stopTask(debug);
				startTask(bpmConfig);
				wait1Msec(1000);
				while (mode == "bpm") {
					wait1Msec(CHANGE);
					if (nLCDButtons == 1) {
						if (bpm > 1) {
							bpm = bpm - 1;
						}
					}
					else if (nLCDButtons == 4) {
						bpm = bpm + 1;
					}
					else if (nLCDButtons == 2) {
						mode = "debug";
					}
				}
			}
			else if (nLCDButtons == 2 || mode == "spm") {
				mode = "spm";
				stopTask(debug);
				startTask(spmConfig);
				wait1Msec(1000);
				while (mode == "spm") {
					wait1Msec(CHANGE);
					if (nLCDButtons == 1) {
						if (spm > 1) {
							spm = spm - 1;
						}
					}
					else if (nLCDButtons == 4) {
						spm = spm + 1;
					}
					else if (nLCDButtons == 2) {
						mode = "debug";
					}
				}
			}
			else if (nLCDButtons == 4 || mode == "pitch") {
				mode = "pitch";
				stopTask(debug);
				startTask(pitchConfig);
				wait1Msec(1000);
				while (mode == "pitch") {
					wait1Msec(CHANGE);
					if (nLCDButtons == 1) {
						if (pitch > 0.01) {
							pitch = pitch - 0.01;
						}
					}
					else if (nLCDButtons == 4) {
						pitch = pitch + 0.01;
					}
					else if (nLCDButtons == 2) {
						mode = "debug";
					}
				}
			}
			if (SensorValue[line] < 2500) {
				stopTask(debug);
				stopTask(strobe);
				stopTask(music);
				stopTask(playback);
				stopTask(bpmConfig);
				stopTask(spmConfig);
				stopTask(pitchConfig);
				motor[flashlight] = 0;
				bLCDBacklight = false;
				clearLCDLine(0);
				clearLCDLine(1);
				power = "off";
				wait1Msec(1000);
			}
		}
		else if (power == "off") {
			if (SensorValue[line] < 2500) {
				power = "on";
				wait1Msec(1000);
				startTask(strobe);
				startTask(music);
				mode = "debug";
			}
		}
	}
}
